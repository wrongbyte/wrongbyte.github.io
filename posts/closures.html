<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>What are closures?</title><meta name="description" content="my site"/><link rel="icon" href="favicon.ico"/><link rel="shortcut icon" href="favicon.ico"/><meta property="og:title" content="What are closures?"/><meta property="og:description" content="Let&#x27;s dive deep into scopes, lifetimes, variables and functions"/><meta property="og:image" content="https://pbs.twimg.com/media/FMfaMdVUYAAtgp2?format=jpg&amp;name=large"/><meta name="twitter:card" content="Let&#x27;s dive deep into scopes, lifetimes, variables and functions"/><meta name="twitter:title" content="What are closures?"/><meta name="twitter:description" content="Let&#x27;s dive deep into scopes, lifetimes, variables and functions"/><meta name="twitter:image" content="https://pbs.twimg.com/media/FMfaMdVUYAAtgp2?format=jpg&amp;name=large"/><meta name="next-head-count" content="13"/><link rel="preload" href="/_next/static/css/19506f6b591e2b17.css" as="style"/><link rel="stylesheet" href="/_next/static/css/19506f6b591e2b17.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="data:text/javascript;base64,IWZ1bmN0aW9uKCl7dHJ5IHt2YXIgZD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7dmFyIG49J2RhdGEtdGhlbWUnO3ZhciBzID0gJ3NldEF0dHJpYnV0ZSc7dmFyIGU9bG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3RoZW1lJyk7aWYoInN5c3RlbSI9PT1lfHwoIWUmJnRydWUpKXt2YXIgdD0iKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSIsbT13aW5kb3cubWF0Y2hNZWRpYSh0KTtpZihtLm1lZGlhIT09dHx8bS5tYXRjaGVzKXtkLnN0eWxlLmNvbG9yU2NoZW1lID0gJ2RhcmsnO2Rbc10obiwgJ2RhcmsnKX1lbHNle2Quc3R5bGUuY29sb3JTY2hlbWUgPSAnbGlnaHQnO2Rbc10obiwgJ2xpZ2h0Jyl9fWVsc2UgaWYoZSl7ZFtzXShuLCBlfHwgJycpfWlmKGU9PT0nbGlnaHQnfHxlPT09J2RhcmsnKWQuc3R5bGUuY29sb3JTY2hlbWU9ZX1jYXRjaChlKXt9fSgp" id="next-themes-script" defer="" data-nscript="beforeInteractive"></script><script src="/_next/static/chunks/webpack-5c9a0d80fa7df27e.js" defer=""></script><script src="/_next/static/chunks/framework-a070cbfff3c750c5.js" defer=""></script><script src="/_next/static/chunks/main-ef558cc4c27e2f83.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c8af879f3541988c.js" defer=""></script><script src="/_next/static/chunks/5040-f3dafc0029c0dd85.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-08a5edc38f7a5ec4.js" defer=""></script><script src="/_next/static/DnJIOPR1TFqQsamicNB0s/_buildManifest.js" defer=""></script><script src="/_next/static/DnJIOPR1TFqQsamicNB0s/_ssgManifest.js" defer=""></script><script src="/_next/static/DnJIOPR1TFqQsamicNB0s/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="flex flex-col h-screen justify-between"><header><a class="text-6xl font-name font-semibold text-black-600 mt-10 flex justify-center" href="/">wrongbyte</a><div class="pages flex justify-center gap-5 mt-2 text-gray-500"><a class="false" href="/">posts</a><a class="false" href="/about">about</a><a class="false">writeups</a><a class="inline" href="https://github.com/wrongbyte">github</a><a class="inline cursor-pointer">dark<!-- --> theme</a></div><div class="py-4"><div class="w-full border-t hr border-gray-300"></div></div></header><main class="xl:w-7/12 lg:w-4/5 w-11/12 mx-auto mt-3 mb-auto"><article><h1 class="font-title text-3xl text-center mb-4">What are closures?</h1><p class="text-gray-500 mb-1">Thu Sep 29 2022</p><p>The concept of <em>closure</em> is important when it comes to understanding how languages such as Javascript work - and how scopes, lifetimes and references come together and can be combined to provide useful features to programmers.</p>
<h2>Variables and their scopes</h2>
<h3>1 - Local and global scope</h3>
<p>Every time you use a variable inside a function, this variable needs to be declared somewhere - and this place can be the <strong>local scope</strong> (inside of the function) or the <strong>global scope</strong>.
Variables declared in the local scope are only accessible inside of their parent function - which means you cannot reference them outside of the function:</p>
<pre><div class="codeBlock"><span style="font-size:inherit;font-family:inherit;background:#282a36;color:#f8f8f2;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px;float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span></code><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">function() {
  let a = 1;
  console.log(a); // works
}    
console.log(a); // fails
</code></span></div></pre>
<p>In the example above, written in JS, we get an <span class="code">Uncaught ReferenceError: a is not defined</span>.</p>
<p>However, by declaring <span class="code">a</span> as a global variable, we can reference it anywhere in our code:</p>
<pre><div class="codeBlock"><span style="font-size:inherit;font-family:inherit;background:#282a36;color:#f8f8f2;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px;float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span></code><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">var a = 1;
function() {
  console.log(a); // works
}    
console.log(a); // works
</code></span></div></pre>
<h3>2 - Lifetime of entities</h3>
<p>The behavior above happens because entities (variables, constants, etc) have different <strong>lifetimes</strong> across a program depending on their <strong>scope</strong>. The definition of the &quot;lifetime&quot; of an entity can be thought as the period from its creation (allocating memory for it) to its destruction (deallocating the memory used for this variable).</p>
<p>A <strong>global variable has the same lifetime of the entire program</strong>. <strong>Local variables</strong>, however, <strong>have specific lifetimes</strong>, so they may not be &quot;alive&quot; during the entire program’s lifecycle.
Hence, the underlying programming language must provide a way to deal which such cases, such as manual memory management or some kind of garbage collector. Otherwise, one could stumble upon a <em>dangling reference</em> when not careful enough, since deallocated variables cannot be referenced.</p>
<p>This dynamic is important to understand because we&#x27;ll eventually get into a tricky question:</p>
<p><em>What would happen if we wanted to reference a variable outside of its original scope?</em></p>
<h3>3 - Nested functions</h3>
<p>There is a special use case of functions in which we face the question above.
Let&#x27;s say we wanted to create a function inside of another function. Let&#x27;s call them <span class="code">outer</span> and <span class="code">inner</span>.</p>
<pre><div class="codeBlock"><span style="font-size:inherit;font-family:inherit;background:#282a36;color:#f8f8f2;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px;float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span></code><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const outer = function() {
  const inner = function() {
     console.log(&quot;hello&quot;);
  }
}
</code></span></div></pre>
<p>Everything declared inside of <span class="code">inner</span> has now access to the scope of <span class="code">outer</span>.
It means that we can declare variables inside of <span class="code">outer</span> and then use them inside of <span class="code">inner</span>, as it follows:</p>
<pre><div class="codeBlock"><span style="font-size:inherit;font-family:inherit;background:#282a36;color:#f8f8f2;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px;float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span></code><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const outer = function() {
  const a = 1;
  const inner = function() {
    console.log(a);
  }
  return inner;
}

var fnc = outer(); // execute outer to get inner 
fnc();

</code></span></div></pre>
<p>We can then return <span class="code">inner</span> from <span class="code">outer</span>. This part is important because it permits <span class="code">inner</span> to leave the scope of <span class="code">outer</span>.
After that, we assign the return of outer to a variable <span class="code">fnc</span>, which we can execute to get <span class="code">inner</span>.</p>
<p>Therefore, we now have all variables of <span class="code">inner</span>, declared in <span class="code">outer</span>, <em>closed</em> under this function.</p>
<p><strong>What we&#x27;ll seeing here is basically the implementation of <em>closures</em> in Javascript: a function that has access to the additional data from its surrounding scope.</strong></p>
<p>Therefore, we can define a closure as:</p>
<pre><span class="code">1 - A function and
2 - A reference to that function&#x27;s outer scope
</span></pre>
<p>In the example above, our <u>function</u> is <span class="code">inner</span> and the <u>outer scope</u> is the scope of <span class="code">outer</span>, which has the variable <span class="code">a</span>. Without keeping a reference to this surrounding scope, we would not be able to retrieve the value of <span class="code">a</span>. Once we have a reference to this surrounding scope, we have a closure.</p>
<h3>Back to scope and lifetimes: what would happen if we didn&#x27;t have closures?</h3>
<p>There are languages that don&#x27;t implement closures.
C is a good example: in C, you won&#x27;t have closures as well as native support for nested functions.
Using the simplified definition we&#x27;ve seen before, we can say that what&#x27;s needed to implement closures is a record of the function along with its environment.
To do this in C, there would be necessary to use structs, function pointers and a lot of fuzzy code. Furthermore, it would be necessary to have support for nested functions, which C doesn&#x27;t have by default. Since closures are only meaningful when a function needs to be executed outside of the scope in which it was originally declared, having nested functions is essential for this concept to work.
A lot of work, huh?</p>
<h3>How Javascript solves it?</h3>
<p>We already learned that JS implements closures and what they are. But how does it work under the hood?</p>
<p>Every function in JavaScript maintains a reference to its outer environment. This reference is used to determine the execution context of the function when it is invoked, and therefore enables the function to &quot;see&quot; variables declared outside of it.
It creates a kind of <em>state</em> particular to the functions declared in the same <em>lexical environment</em>.
In addition, if we have functions that call other functions that in turn call even more functions, JS creates a chain of references to the outer lexical environments - which is called the <em>scope chain.</em> Therefore, closures in Javascript can become quite useful - and we are going to see a few uses for them now.</p>
<h2>Why are closures useful?</h2>
<p>If you have ever programmed using an object-oriented language, you will probably know the concept of classes and states.
Once you use a closure, you are creating the equivalent of a private state associated with a function.</p>
<pre><div class="codeBlock"><span style="font-size:inherit;font-family:inherit;background:#282a36;color:#f8f8f2;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px;float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span></code><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">function foo() {
  const secret = Math.trunc(Math.random() * 100)
  return function inner() {
    console.log(`The secret number is ${secret}.`)
  }
}
const f = foo() // 
f()
</code></span></div></pre>
<p>In the example above, <span class="code">secret</span> is not directly accessible from outside <span class="code">foo</span>. <span class="code">foo</span> then creates a kind of encapsulation similar to what we see in OOP, which is useful in several cases. Furthermore, JavaScript did not have a class syntax until 2015 - making the use of closures an alternative.</p>
<p>Finally, there are several other use cases for closures - such as <em>currying</em>, in functional programming, event-oriented programming and so on.</p>
<blockquote>
<p>:bulb: Further reading: <a class="article-link" href="https://gist.github.com/wrongbyte/3b5f0b09706d818e24c5b18c4b2639cb">Nested functions, closures and first-class functions</a></p>
</blockquote></article><div class="py-4"><div class="w-full border-t hr border-gray-300 mt-3"></div></div></main><footer class=" flex justify-center"><span class="mb-3">• wrongbyte © • 2022 •</span></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"What are closures?","description":"Let's dive deep into scopes, lifetimes, variables and functions","date":"Thu Sep 29 2022","content":"\nThe concept of _closure_ is important when it comes to understanding how languages such as Javascript work - and how scopes, lifetimes and references come together and can be combined to provide useful features to programmers.\n\n## Variables and their scopes\n### 1 - Local and global scope\nEvery time you use a variable inside a function, this variable needs to be declared somewhere - and this place can be the **local scope** (inside of the function) or the **global scope**.\nVariables declared in the local scope are only accessible inside of their parent function - which means you cannot reference them outside of the function:\n```javascript\nfunction() {\n  let a = 1;\n  console.log(a); // works\n}    \nconsole.log(a); // fails\n```\nIn the example above, written in JS, we get an `Uncaught ReferenceError: a is not defined`.\n\nHowever, by declaring `a` as a global variable, we can reference it anywhere in our code:\n```js\nvar a = 1;\nfunction() {\n  console.log(a); // works\n}    \nconsole.log(a); // works\n```\n\n### 2 - Lifetime of entities\nThe behavior above happens because entities (variables, constants, etc) have different **lifetimes** across a program depending on their **scope**. The definition of the \"lifetime\" of an entity can be thought as the period from its creation (allocating memory for it) to its destruction (deallocating the memory used for this variable).\n\nA **global variable has the same lifetime of the entire program**. **Local variables**, however, **have specific lifetimes**, so they may not be \"alive\" during the entire program’s lifecycle. \nHence, the underlying programming language must provide a way to deal which such cases, such as manual memory management or some kind of garbage collector. Otherwise, one could stumble upon a _dangling reference_ when not careful enough, since deallocated variables cannot be referenced.\n\nThis dynamic is important to understand because we'll eventually get into a tricky question:\n\n_What would happen if we wanted to reference a variable outside of its original scope?_\n\n### 3 - Nested functions\nThere is a special use case of functions in which we face the question above.\nLet's say we wanted to create a function inside of another function. Let's call them `outer` and `inner`.\n\n```js\nconst outer = function() {\n  const inner = function() {\n     console.log(\"hello\");\n  }\n}\n```\n\nEverything declared inside of `inner` has now access to the scope of `outer`. \nIt means that we can declare variables inside of `outer` and then use them inside of `inner`, as it follows:\n\n\n```js\nconst outer = function() {\n  const a = 1;\n  const inner = function() {\n    console.log(a);\n  }\n  return inner;\n}\n\nvar fnc = outer(); // execute outer to get inner \nfnc();\n\n```\n\nWe can then return `inner` from `outer`. This part is important because it permits `inner` to leave the scope of `outer`.\nAfter that, we assign the return of outer to a variable `fnc`, which we can execute to get `inner`.\n\nTherefore, we now have all variables of `inner`, declared in `outer`, _closed_ under this function. \n\n**What we'll seeing here is basically the implementation of _closures_ in Javascript: a function that has access to the additional data from its surrounding scope.**\n\nTherefore, we can define a closure as:\n```\n1 - A function and\n2 - A reference to that function's outer scope\n```\n\nIn the example above, our \u003cu\u003efunction\u003c/u\u003e is `inner` and the \u003cu\u003eouter scope\u003c/u\u003e is the scope of `outer`, which has the variable `a`. Without keeping a reference to this surrounding scope, we would not be able to retrieve the value of `a`. Once we have a reference to this surrounding scope, we have a closure.\n\n### Back to scope and lifetimes: what would happen if we didn't have closures?\nThere are languages that don't implement closures. \nC is a good example: in C, you won't have closures as well as native support for nested functions. \nUsing the simplified definition we've seen before, we can say that what's needed to implement closures is a record of the function along with its environment. \nTo do this in C, there would be necessary to use structs, function pointers and a lot of fuzzy code. Furthermore, it would be necessary to have support for nested functions, which C doesn't have by default. Since closures are only meaningful when a function needs to be executed outside of the scope in which it was originally declared, having nested functions is essential for this concept to work.\nA lot of work, huh?\n\n### How Javascript solves it?\nWe already learned that JS implements closures and what they are. But how does it work under the hood?\n\nEvery function in JavaScript maintains a reference to its outer environment. This reference is used to determine the execution context of the function when it is invoked, and therefore enables the function to \"see\" variables declared outside of it.\nIt creates a kind of _state_ particular to the functions declared in the same _lexical environment_.\nIn addition, if we have functions that call other functions that in turn call even more functions, JS creates a chain of references to the outer lexical environments - which is called the _scope chain._ Therefore, closures in Javascript can become quite useful - and we are going to see a few uses for them now.\n\n## Why are closures useful?\n\nIf you have ever programmed using an object-oriented language, you will probably know the concept of classes and states.\nOnce you use a closure, you are creating the equivalent of a private state associated with a function.\n```js\nfunction foo() {\n  const secret = Math.trunc(Math.random() * 100)\n  return function inner() {\n    console.log(`The secret number is ${secret}.`)\n  }\n}\nconst f = foo() // \nf()\n```\n\nIn the example above, `secret` is not directly accessible from outside `foo`. `foo` then creates a kind of encapsulation similar to what we see in OOP, which is useful in several cases. Furthermore, JavaScript did not have a class syntax until 2015 - making the use of closures an alternative.\n\nFinally, there are several other use cases for closures - such as _currying_, in functional programming, event-oriented programming and so on.\n\n\u003e :bulb: Further reading: [Nested functions, closures and first-class functions](https://gist.github.com/wrongbyte/3b5f0b09706d818e24c5b18c4b2639cb)","slug":"closures","source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      em: \"em\",\n      h2: \"h2\",\n      h3: \"h3\",\n      strong: \"strong\",\n      pre: \"pre\",\n      code: \"code\",\n      blockquote: \"blockquote\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"The concept of \", _jsx(_components.em, {\n          children: \"closure\"\n        }), \" is important when it comes to understanding how languages such as Javascript work - and how scopes, lifetimes and references come together and can be combined to provide useful features to programmers.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Variables and their scopes\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"1 - Local and global scope\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Every time you use a variable inside a function, this variable needs to be declared somewhere - and this place can be the \", _jsx(_components.strong, {\n          children: \"local scope\"\n        }), \" (inside of the function) or the \", _jsx(_components.strong, {\n          children: \"global scope\"\n        }), \".\\nVariables declared in the local scope are only accessible inside of their parent function - which means you cannot reference them outside of the function:\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"function() {\\n  let a = 1;\\n  console.log(a); // works\\n}    \\nconsole.log(a); // fails\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"In the example above, written in JS, we get an \", _jsx(_components.code, {\n          children: \"Uncaught ReferenceError: a is not defined\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"However, by declaring \", _jsx(_components.code, {\n          children: \"a\"\n        }), \" as a global variable, we can reference it anywhere in our code:\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"var a = 1;\\nfunction() {\\n  console.log(a); // works\\n}    \\nconsole.log(a); // works\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"2 - Lifetime of entities\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The behavior above happens because entities (variables, constants, etc) have different \", _jsx(_components.strong, {\n          children: \"lifetimes\"\n        }), \" across a program depending on their \", _jsx(_components.strong, {\n          children: \"scope\"\n        }), \". The definition of the \\\"lifetime\\\" of an entity can be thought as the period from its creation (allocating memory for it) to its destruction (deallocating the memory used for this variable).\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"A \", _jsx(_components.strong, {\n          children: \"global variable has the same lifetime of the entire program\"\n        }), \". \", _jsx(_components.strong, {\n          children: \"Local variables\"\n        }), \", however, \", _jsx(_components.strong, {\n          children: \"have specific lifetimes\"\n        }), \", so they may not be \\\"alive\\\" during the entire program’s lifecycle.\\nHence, the underlying programming language must provide a way to deal which such cases, such as manual memory management or some kind of garbage collector. Otherwise, one could stumble upon a \", _jsx(_components.em, {\n          children: \"dangling reference\"\n        }), \" when not careful enough, since deallocated variables cannot be referenced.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This dynamic is important to understand because we'll eventually get into a tricky question:\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"What would happen if we wanted to reference a variable outside of its original scope?\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"3 - Nested functions\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"There is a special use case of functions in which we face the question above.\\nLet's say we wanted to create a function inside of another function. Let's call them \", _jsx(_components.code, {\n          children: \"outer\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"const outer = function() {\\n  const inner = function() {\\n     console.log(\\\"hello\\\");\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Everything declared inside of \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \" has now access to the scope of \", _jsx(_components.code, {\n          children: \"outer\"\n        }), \".\\nIt means that we can declare variables inside of \", _jsx(_components.code, {\n          children: \"outer\"\n        }), \" and then use them inside of \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \", as it follows:\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"const outer = function() {\\n  const a = 1;\\n  const inner = function() {\\n    console.log(a);\\n  }\\n  return inner;\\n}\\n\\nvar fnc = outer(); // execute outer to get inner \\nfnc();\\n\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"We can then return \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \" from \", _jsx(_components.code, {\n          children: \"outer\"\n        }), \". This part is important because it permits \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \" to leave the scope of \", _jsx(_components.code, {\n          children: \"outer\"\n        }), \".\\nAfter that, we assign the return of outer to a variable \", _jsx(_components.code, {\n          children: \"fnc\"\n        }), \", which we can execute to get \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Therefore, we now have all variables of \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \", declared in \", _jsx(_components.code, {\n          children: \"outer\"\n        }), \", \", _jsx(_components.em, {\n          children: \"closed\"\n        }), \" under this function.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsxs(_components.strong, {\n          children: [\"What we'll seeing here is basically the implementation of \", _jsx(_components.em, {\n            children: \"closures\"\n          }), \" in Javascript: a function that has access to the additional data from its surrounding scope.\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Therefore, we can define a closure as:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"1 - A function and\\n2 - A reference to that function's outer scope\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"In the example above, our \", _jsx(\"u\", {\n          children: \"function\"\n        }), \" is \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \" and the \", _jsx(\"u\", {\n          children: \"outer scope\"\n        }), \" is the scope of \", _jsx(_components.code, {\n          children: \"outer\"\n        }), \", which has the variable \", _jsx(_components.code, {\n          children: \"a\"\n        }), \". Without keeping a reference to this surrounding scope, we would not be able to retrieve the value of \", _jsx(_components.code, {\n          children: \"a\"\n        }), \". Once we have a reference to this surrounding scope, we have a closure.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Back to scope and lifetimes: what would happen if we didn't have closures?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"There are languages that don't implement closures.\\nC is a good example: in C, you won't have closures as well as native support for nested functions.\\nUsing the simplified definition we've seen before, we can say that what's needed to implement closures is a record of the function along with its environment.\\nTo do this in C, there would be necessary to use structs, function pointers and a lot of fuzzy code. Furthermore, it would be necessary to have support for nested functions, which C doesn't have by default. Since closures are only meaningful when a function needs to be executed outside of the scope in which it was originally declared, having nested functions is essential for this concept to work.\\nA lot of work, huh?\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"How Javascript solves it?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"We already learned that JS implements closures and what they are. But how does it work under the hood?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Every function in JavaScript maintains a reference to its outer environment. This reference is used to determine the execution context of the function when it is invoked, and therefore enables the function to \\\"see\\\" variables declared outside of it.\\nIt creates a kind of \", _jsx(_components.em, {\n          children: \"state\"\n        }), \" particular to the functions declared in the same \", _jsx(_components.em, {\n          children: \"lexical environment\"\n        }), \".\\nIn addition, if we have functions that call other functions that in turn call even more functions, JS creates a chain of references to the outer lexical environments - which is called the \", _jsx(_components.em, {\n          children: \"scope chain.\"\n        }), \" Therefore, closures in Javascript can become quite useful - and we are going to see a few uses for them now.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Why are closures useful?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"If you have ever programmed using an object-oriented language, you will probably know the concept of classes and states.\\nOnce you use a closure, you are creating the equivalent of a private state associated with a function.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"function foo() {\\n  const secret = Math.trunc(Math.random() * 100)\\n  return function inner() {\\n    console.log(`The secret number is ${secret}.`)\\n  }\\n}\\nconst f = foo() // \\nf()\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"In the example above, \", _jsx(_components.code, {\n          children: \"secret\"\n        }), \" is not directly accessible from outside \", _jsx(_components.code, {\n          children: \"foo\"\n        }), \". \", _jsx(_components.code, {\n          children: \"foo\"\n        }), \" then creates a kind of encapsulation similar to what we see in OOP, which is useful in several cases. Furthermore, JavaScript did not have a class syntax until 2015 - making the use of closures an alternative.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Finally, there are several other use cases for closures - such as \", _jsx(_components.em, {\n          children: \"currying\"\n        }), \", in functional programming, event-oriented programming and so on.\"]\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\":bulb: Further reading: \", _jsx(_components.a, {\n            href: \"https://gist.github.com/wrongbyte/3b5f0b09706d818e24c5b18c4b2639cb\",\n            children: \"Nested functions, closures and first-class functions\"\n          })]\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"closures"},"buildId":"DnJIOPR1TFqQsamicNB0s","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>